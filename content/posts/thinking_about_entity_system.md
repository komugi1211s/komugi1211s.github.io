---
title: "ゲームのエンティティを扱う上でのアプローチについて"
date: 2022-04-17T12:06:30+09:00
subtitle: Approaching Entity Management
draft: true
---

自分なりに納得の行くエンティティシステムの実装に関するメモ。また同じ楔を踏んでプロジェクトを折らないようにする為に残しておく。
<!--more-->

## 学んだこと
- **500エンティティぐらいなら仮想関数は大した重みではない**
- **2Dゲームとかならよほどヘマをしない限りド直球な書き方でも良い**
- **他の書き方をするのはデータをしっかり知って必要性が出てきてから**

## 発端
自分はゲームを作ろうとしては詰まって失敗という流れをかれこれ50回は繰り返している。大抵の場合はどういう風にゲーム内のオブジェクトを管理するかという部分で試行錯誤して詰まってしまうからだ。

「仮想関数や散乱したメモリへのランダムアクセスは遅いので、可能ならエンティティは継続メモリ内に押し込んでキャッシュに押し込めるようにする」という何処で学んだか分からない教えを意地でも守ろうとして、結局折れて辞めてしまうのである。

~~~~~~~~~~~~~~ C
// ルール1: 複数継承はわけがわからなくなるので禁止
// ルール2: 仮想関数はデータがPODでなくなるし、２回もポインタルックアップをするなどキャッシュミスを頻発するので禁止
// ルール3: メモリのあちらこちらにエンティティを確保するのはリークやキャッシュミスの可能性があるので禁止
// ルール4: stdライブラリは上記3つを全てぶっ壊しにかかるので禁止
struct Entity {
    // 大量のメンバー
};

#define COUNT_OF_ENTITIES 4096
static Entity entities[COUNT_OF_ENTITIES];

for (int i = 0; i < COUNT_OF_ENTITIES; ++i) {
    Entity *entity = &entities[i];

    // 全エンティティ共通の処理
    common_entity_operation(entity);

    switch (entity->type) {
        case ENTITY_CAT: ...; break;
        case ENTITY_DOG: ...; break;
    }
}
~~~~~~~~~~~~~~

この書き方は色々な欠点がある。各エンティティは全て１つの固定長配列で管理されるのでアクセスそのものは早いが、エンティティの種類が増えてくればswitch文もそれに合わせて肥大化していく。数種類のエンティティだけであればコレでも良いかもしれないが、２桁に乗った段階でもう既にウンザリしてきているはず。

それでも自分が勝手に定めたよくわからない指標を満たす書き方は考える限りではこれしかなかった。なんとかしてもっと書きやすくする方法はないかと何度も考えて、折れて辞めてしまうのだ。

## Breakthrough 

先日ゲームジャムに参加した時、このルールを破る形で作業を進めた割には納得の行く動作をしてくれた。実際にエンティティコードを書く必要があった訳ではないが、この機会に自分が最も詰まりやすい部分のルールをまた見直してみようと考え、自分に最も合うアプローチを一から探し直すことにした。

今回、以下の４つを比較対象として、各アプローチのサンプルコードとベンチマークを確保して自分なりのスイートスポットを探す。

- (客観的な) アップデート・ドロー処理の速度
- (客観的な) 削除・作成のコード量
- (主観的な) 書きやすさ
- (主観的な) エンティティ同士のインタラクトのし安さ

ここで「ゲーム内のオブジェクト」は他のゲームエンジンではゲームオブジェクトとかアクターとかエンティティと呼ばれているやつで、いわゆるゲーム世界に影響を及ぼすデータとそれに強く関連づいた処理全体のことを指す。

また、エンティティ同士の参照はアプローチに関係なく配列へのインデックスで行う。SQLとかの外部キーと同じ。

## アプローチ一覧
### 1. 仮想関数 + エンティティ毎にnew

何処かのStackoverflow[^Here]には「このアプローチは大抵のゲームエンジンが取る方法」と書いていたが信憑性は不明。

利点は一つの`update`関数でエンティティごとの処理を行うので書きやすいこと。各エンティティは型レベルで区別されるので混同してしまうことがないこと。

欠点は型情報をEnumなどで維持しない限り、特定のエンティティに対する関数を呼びたい際は`dynamic_cast`で動的キャストを試みる他ないこと。また各エンティティ毎に異なるサイズとなるので、固定配列などに押し込んでキャッシュの恩恵を受けることができない。

[^Here]: [Handling entities in a game](https://stackoverflow.com/a/4112877)

~~~~~~~~~~~~~~ CPP
// ベースのエンティティ
struct Entity {
    // エンティティの情報…
    virtual void update(float dt) = 0;
    virtual void draw(Renderer *ren) = 0;
};

struct Cat: public Entity {
    void update(float dt) override { ... }
    void draw(Renderer *ren) override { ... }
};

struct Dog: public Entity {
    void update(float dt) override { ... }
    void draw(Renderer *ren) override { ... }
};

std::vector<Entity *> entities;
entities.push_back(new Cat());
entities.push_back(new Dog());

for (auto e: entities) { // can copy: it's just a pointer.
    if (e) {
        e->update(1.0f/60.0f);
    }
}
~~~~~~~~~~~~~~

このアプローチは問題を過剰に簡略化しすぎている印象を受ける。このコードだけでも「エンティティはUpdateとDrawを毎フレーム１回呼ばれる」とか「Update処理はエンティティに纏わる全ての処理をこなす」等の暗黙の前提の下に成り立っている。物理演算を行う者と行わない者は`update`の中でIf文を書くのだろうか。特定のエンティティのみが持つようなデータと共通のデータの境界線は何なのだろうか。
